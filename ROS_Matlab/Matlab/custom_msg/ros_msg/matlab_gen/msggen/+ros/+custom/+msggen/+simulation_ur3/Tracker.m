classdef Tracker < ros.Message
    %Tracker MATLAB implementation of simulation_ur3/Tracker
    %   This class was automatically generated by
    %   ros.msg.internal.gen.MessageClassGenerator.
    
    %   Copyright 2014-2020 The MathWorks, Inc.
    
    %#ok<*INUSD>
    
    properties (Constant)
        MessageType = 'simulation_ur3/Tracker' % The ROS message type
    end
    
    properties (Constant, Hidden)
        MD5Checksum = '8c54a711bf68e69302a10bb7bfb7ca79' % The MD5 Checksum of the message definition
    end
    
    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    properties (Dependent)
        Up
        Down
        Left
        Right
        Forward
        Backward
        InitJoint
        InitPosition
    end
    
    properties (Constant, Hidden)
        PropertyList = {'Backward', 'Down', 'Forward', 'InitJoint', 'InitPosition', 'Left', 'Right', 'Up'} % List of non-constant message properties
        ROSPropertyList = {'backward', 'down', 'forward', 'init_joint', 'init_position', 'left', 'right', 'up'} % List of non-constant ROS message properties
    end
    
    methods
        function obj = Tracker(msg)
            %Tracker Construct the message object Tracker
            import com.mathworks.toolbox.ros.message.MessageInfo;
            
            % Support default constructor
            if nargin == 0
                obj.JavaMessage = obj.createNewJavaMessage;
                return;
            end
            
            % Construct appropriate empty array
            if isempty(msg)
                obj = obj.empty(0,1);
                return;
            end
            
            % Make scalar construction fast
            if isscalar(msg)
                % Check for correct input class
                if ~MessageInfo.compareTypes(msg(1), obj.MessageType)
                    error(message('ros:mlros:message:NoTypeMatch', obj.MessageType, ...
                        char(MessageInfo.getType(msg(1))) ));
                end
                obj.JavaMessage = msg(1);
                return;
            end
            
            % Check that this is a vector of scalar messages. Since this
            % is an object array, use arrayfun to verify.
            if ~all(arrayfun(@isscalar, msg))
                error(message('ros:mlros:message:MessageArraySizeError'));
            end
            
            % Check that all messages in the array have the correct type
            if ~all(arrayfun(@(x) MessageInfo.compareTypes(x, obj.MessageType), msg))
                error(message('ros:mlros:message:NoTypeMatchArray', obj.MessageType));
            end
            
            % Construct array of objects if necessary
            objType = class(obj);
            for i = 1:length(msg)
                obj(i,1) = feval(objType, msg(i)); %#ok<AGROW>
            end
        end
        
        function up = get.Up(obj)
            %get.Up Get the value for property Up
            up = double(obj.JavaMessage.getUp);
        end
        
        function set.Up(obj, up)
            %set.Up Set the value for property Up
            validateattributes(up, {'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'Up');
            
            obj.JavaMessage.setUp(up);
        end
        
        function down = get.Down(obj)
            %get.Down Get the value for property Down
            down = double(obj.JavaMessage.getDown);
        end
        
        function set.Down(obj, down)
            %set.Down Set the value for property Down
            validateattributes(down, {'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'Down');
            
            obj.JavaMessage.setDown(down);
        end
        
        function left = get.Left(obj)
            %get.Left Get the value for property Left
            left = double(obj.JavaMessage.getLeft);
        end
        
        function set.Left(obj, left)
            %set.Left Set the value for property Left
            validateattributes(left, {'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'Left');
            
            obj.JavaMessage.setLeft(left);
        end
        
        function right = get.Right(obj)
            %get.Right Get the value for property Right
            right = double(obj.JavaMessage.getRight);
        end
        
        function set.Right(obj, right)
            %set.Right Set the value for property Right
            validateattributes(right, {'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'Right');
            
            obj.JavaMessage.setRight(right);
        end
        
        function forward = get.Forward(obj)
            %get.Forward Get the value for property Forward
            forward = double(obj.JavaMessage.getForward);
        end
        
        function set.Forward(obj, forward)
            %set.Forward Set the value for property Forward
            validateattributes(forward, {'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'Forward');
            
            obj.JavaMessage.setForward(forward);
        end
        
        function backward = get.Backward(obj)
            %get.Backward Get the value for property Backward
            backward = double(obj.JavaMessage.getBackward);
        end
        
        function set.Backward(obj, backward)
            %set.Backward Set the value for property Backward
            validateattributes(backward, {'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'Backward');
            
            obj.JavaMessage.setBackward(backward);
        end
        
        function initjoint = get.InitJoint(obj)
            %get.InitJoint Get the value for property InitJoint
            initjoint = logical(obj.JavaMessage.getInitJoint);
        end
        
        function set.InitJoint(obj, initjoint)
            %set.InitJoint Set the value for property InitJoint
            validateattributes(initjoint, {'logical', 'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'InitJoint');
            
            obj.JavaMessage.setInitJoint(initjoint);
        end
        
        function initposition = get.InitPosition(obj)
            %get.InitPosition Get the value for property InitPosition
            initposition = logical(obj.JavaMessage.getInitPosition);
        end
        
        function set.InitPosition(obj, initposition)
            %set.InitPosition Set the value for property InitPosition
            validateattributes(initposition, {'logical', 'numeric'}, {'nonempty', 'scalar'}, 'Tracker', 'InitPosition');
            
            obj.JavaMessage.setInitPosition(initposition);
        end
    end
    
    methods (Access = protected)
        function cpObj = copyElement(obj)
            %copyElement Implements deep copy behavior for message
            
            % Call default copy method for shallow copy
            cpObj = copyElement@ros.Message(obj);
            
            % Create a new Java message object
            cpObj.JavaMessage = obj.createNewJavaMessage;
            
            % Iterate over all primitive properties
            cpObj.Up = obj.Up;
            cpObj.Down = obj.Down;
            cpObj.Left = obj.Left;
            cpObj.Right = obj.Right;
            cpObj.Forward = obj.Forward;
            cpObj.Backward = obj.Backward;
            cpObj.InitJoint = obj.InitJoint;
            cpObj.InitPosition = obj.InitPosition;
        end
        
        function reload(obj, strObj)
            %reload Called by loadobj to assign properties
            obj.Up = strObj.Up;
            obj.Down = strObj.Down;
            obj.Left = strObj.Left;
            obj.Right = strObj.Right;
            obj.Forward = strObj.Forward;
            obj.Backward = strObj.Backward;
            obj.InitJoint = strObj.InitJoint;
            obj.InitPosition = strObj.InitPosition;
        end
    end
    
    methods (Access = ?ros.Message)
        function strObj = saveobj(obj)
            %saveobj Implements saving of message to MAT file
            
            % Return an empty element if object array is empty
            if isempty(obj)
                strObj = struct.empty;
                return
            end
            
            strObj.Up = obj.Up;
            strObj.Down = obj.Down;
            strObj.Left = obj.Left;
            strObj.Right = obj.Right;
            strObj.Forward = obj.Forward;
            strObj.Backward = obj.Backward;
            strObj.InitJoint = obj.InitJoint;
            strObj.InitPosition = obj.InitPosition;
        end
    end
    
    methods (Static, Access = {?matlab.unittest.TestCase, ?ros.Message})
        function obj = loadobj(strObj)
            %loadobj Implements loading of message from MAT file
            
            % Return an empty object array if the structure element is not defined
            if isempty(strObj)
                obj = ros.custom.msggen.simulation_ur3.Tracker.empty(0,1);
                return
            end
            
            % Create an empty message object
            obj = ros.custom.msggen.simulation_ur3.Tracker;
            obj.reload(strObj);
        end
    end
end
